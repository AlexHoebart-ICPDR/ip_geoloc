<?php

/**
 * @file
 *
 * Using one or more of a number of optional sources IP Geolocation retrieves
 * and stores geographical and postal address information of your site visitors,
 * based on their IP addresses.
 * It stores this information in a form suitable for further processing,
 * reporting, exporting and display via the Views module.
 * Ready-to-uses views, blocks and maps are provided. For programmers there is
 * also an API.
 */
define('IP_GEOLOC_LOCATION_CHECK_INTERVAL', 60);

define('IP_GEOLOC_MAP_DIV_DEFAULT_STYLE', 'height:300px');
define('IP_GEOLOC_CURRENT_VISITOR_MAP_OPTIONS', '{"mapTypeId":"roadmap", "disableDefaultUI":true, "zoom":15, "zoomControl":true}');
define('IP_GEOLOC_RECENT_VISITORS_MAP_OPTIONS', '{"mapTypeId":"terrain", "disableDefaultUI":true, "zoom":2,  "zoomControl":true}');

define('DOC_GOOGLE_MAP_OPTIONS', 'http://code.google.com/apis/maps/documentation/javascript/reference.html#MapOptions');

require_once 'ip_geoloc_api.inc';
require_once 'ip_geoloc_blocks.inc';

/**
 * Implements hook-help().
 */
function ip_geoloc_help($path, $arg) {
  global $base_path;
  if ($path == 'admin/help#ip_geoloc') {
    return t('Detailed information is on the <a href="!ip_geoloc">IP Geolocation project page</a> and in the <a href="!README">README</a> file',
        array('!ip_geoloc' => url('http://drupal.org/project/ip_geoloc'), '!README' => url(drupal_get_path('module', 'ip_geoloc') . '/README.txt')));
  }
}

/**
 * Implements hook_init().
 *
 * Due to the weight set in ip_geoloc.install this hook is called after all
 * other hook_init() implementations have completed.
 */
function ip_geoloc_init() {

  if (!isset($_SESSION['ip_geoloc'])) {
    ip_geoloc_debug(t('Start of new IP Geolocation session.'));
    $_SESSION['ip_geoloc'] = array('location' => array());
  }
  $location = &$_SESSION['ip_geoloc']['location'];

  if (isset($_SESSION['ip_geoloc']['position_pending_since'])) {
    $time_elapsed = time() - $_SESSION['ip_geoloc']['position_pending_since'];
    ip_geoloc_debug(t('IP Geolocation: location info is now pending for %seconds seconds.', array('%seconds' => $time_elapsed)));
    if ($time_elapsed > 10) {
      watchdog('IP Geolocation', '%ip: location callback is now pending for %seconds seconds',
        array('%ip' => $location['ip_address'], '%seconds' => $time_elapsed), WATCHDOG_NOTICE);
    }
  }

  if (isset($_SESSION['ip_geoloc']['last_position_check'])) {
    $time_elapsed = time() - $_SESSION['ip_geoloc']['last_position_check'];
    $interval = variable_get('ip_geoloc_location_check_interval', IP_GEOLOC_LOCATION_CHECK_INTERVAL);
    if ($time_elapsed <= $interval) {
      ip_geoloc_debug(t('IP Geolocation: next update in %seconds seconds.', array('%seconds' => $interval - $time_elapsed)));
    }
    $check_location = $time_elapsed >= $interval;
  }
  else {
    $check_location = TRUE;
  }

  if (!empty($check_location)) {
    // Erase old result, indicating that further data is pending:
    $_SESSION['ip_geoloc']['location'] = array();
    if (variable_get('ip_geoloc_google_to_reverse_geocode', TRUE)) {
      // Insert some javascript to first retrieve the user's lat/long coords and
      // then use Google Maps API to reverse-geocode these coords into a street
      // address. This is all done via client-side calls, so the Drupal server
      // will not rake up any calls against its Google-imposed quotum,ie the
      // OVER_QUERY_LIMIT.
      // When done the javascript calls us back on the supplied menu callback,
      // '/ip-geoloc-current-location', which receives the geolocation data
      // via the $_POST variable and stores it in $_SESSION['ip_geoloc'].
      ip_geoloc_debug(t('IP Geolocation: initiating services to locate current position and reverse-geocode address...'));
      ip_geoloc_get_current_location('ip-geoloc-current-location');
      $_SESSION['ip_geoloc']['position_pending_since'] = time();
    }
    else {
      if (variable_get('ip_geoloc_smart_ip_as_backup', TRUE)) {
        ip_geoloc_debug(t('IP Geolocation: calling Smart IP to retrieve lat/long and address based on IP.'));
        $location['ip_address'] = ip_address();
        // Note this is a synchronous call, no callback involved.
        ip_geoloc_use_smart_ip_if_enabled($location);
      }
      elseif (module_exists('geoip')) {
        ip_geoloc_debug(t('IP Geolocation: calling GeoIP API to retrieve lat/long and address based on IP.'));
        $location['ip_address'] = ip_address();
        // See what the GeoIP API file lookup produces. Returns immediately.
        ip_geoloc_use_geoip_api($location);
      }
      unset($_SESSION['ip_geoloc']['position_pending_since']);
    }
    // Give contributed modules a chance to add their 2 cents by implementing
    // hook_get_ip_geolocation_alter()
    drupal_alter('get_ip_geolocation', $location);

    $_SESSION['ip_geoloc']['last_position_check'] = time();
  };
  // ip_geoloc_store_location() does nothing, if supplied IP address is empty.
  if (ip_geoloc_store_location($location) > 0) {
    $location['ip_address'] = NULL; // if successfully stored, don't store again
  }
}

/**
 * Implements hook_menu().
 *
 * Defines new menu items.
 */
function ip_geoloc_menu() {
  $items = array();
  // Put the administrative settings under System on the Configuration page.
  $items['admin/config/system/ip_geoloc'] = array(
    'title' => 'IP Geolocation',
    'description' => 'Configure how geolocation information is updated.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ip_geoloc_admin_configure'),
    'access arguments' => array('administer site configuration'),
    'file' => 'ip_geoloc.admin.inc'
  );
  $items['ip-geoloc-current-location'] = array(
    'title' => 'Current location recipient',
    'page callback' => 'ip_geoloc_current_location_ajax_recipient',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Data recipient for javascript function getLocation() (file:
 * ip_geoloc_current_location.js) via menu callback /ip-geoloc-current-location,
 * see function ip_geoloc_menu() above.
 * Receives latitude, longitude, accuracy and address via the global $_POST
 * variable from function getLocations(), which posts these through an AJAX
 * call.
 * @see ip_geoloc_current_location.js
 */
function ip_geoloc_current_location_ajax_recipient() {
  unset($_SESSION['ip_geoloc']['position_pending_since']);

  if (empty($_POST)) {
    watchdog('IP Geolocation', 'No POST data in /ip-geoloc-current-location callback', NULL, WATCHDOG_ERROR);
    return;
  }

  $location = &$_SESSION['ip_geoloc']['location'];
  // Need to set IP address for Smart IP, GeoIP and for the data to be stored.
  $location['ip_address'] = ip_address();

  if (isset($_POST['error'])) {
    // Device/browser does not support getCurrentPosition() or Google reverse-geocode error.
    $error = check_plain($_POST['error']) . ' -- ';
    $result = ip_geoloc_use_smart_ip_if_enabled($location);
    if (!$result && module_exists('geoip')) {
      ip_geoloc_use_geoip_api($location);
      $error .= t('GeoIP API fallback produced: %address', array('%address' => $location['formatted_address']));
    }
    else {
      $error .= $result
        ? t('Smart IP fallback produced: %address', array('%address' => $location['formatted_address']))
        : t('Smart IP not enabled, so no backup address.');
    }
    watchdog('IP Geolocation', $error, NULL, WATCHDOG_NOTICE);
    ip_geoloc_debug('IP Geolocation, ' . $location['ip_address'] . ': ' . $error);
  }
  else {
    foreach ($_POST as $key => $value) {
      $location[check_plain($key)] = check_plain($value);
    }
    ip_geoloc_debug(t('IP Geolocaton: Google reverse-geocoding callback received: !location', array('!location' => ip_geoloc_pretty_print($location))));
  }
  if (ip_geoloc_store_location($location) > 0) {
    $location['ip_address'] = NULL; // if successfully stored, don't store again
  }
}

function ip_geoloc_use_smart_ip_if_enabled(&$location) {
  if (variable_get('ip_geoloc_smart_ip_as_backup', TRUE)) {
    if (module_exists('smart_ip')) {
      $location = smart_ip_get_location($location['ip_address']); //see also: ip_geoloc_smart_ip_get_location_alter()
      return TRUE;
    }
    ip_geoloc_debug(t('IP Geolocation: Smart IP configured as a backup in case the Google Maps reverse-geocode fails. However Smart IP is not enabled.'));
  }
//$location['formatted_address'] = '';
  return FALSE;
}

/**
 * Module GeoIP API does not expose a hook, but it does expose an API.
 *
 * @param $location array to be updated, assumes ['ip_address'] filled out
 */
function ip_geoloc_use_geoip_api(&$location) {
  $geoip_location = (array) geoip_city($location['ip_address']);
  if (!empty($geoip_location)) {
    // Where different convert GeoIP names to our equivalents
    $geoip_location['country'] = $geoip_location['country_name'];
    unset($geoip_location['country_name']);
    $location = array_merge($geoip_location, $location);
    ip_geoloc_format_address($location);
  }
  ip_geoloc_debug(t('IP Geolocation: GeoIP API retrieved: !location', array('!location' => ip_geoloc_pretty_print($location))));
}


/**
 * This is a poorman's version as it doesn't take local format conventions into
 * account. Luckily this is only called as a fallback when lat/long could not
 * be established or the Google reverse-geocode function returned an error.
 * @param $location
 */
function ip_geoloc_format_address(&$location) {
  $location['formatted_address'] = $location['city'];
  if (!empty($location['region'])) {
    $location['formatted_address'] .= ' ' . $location['region'];
  }
  if (!empty($location['postal_code']) && $location['postal_code'] != '-') {
    $location['formatted_address'] .= ' ' . $location['postal_code'] . ',';
  }
  $location['formatted_address'] .= ' ' . $location['country'];
  $location['formatted_address'] = trim($location['formatted_address']);
}

/**
 * Fleshes out the $ip_geoloc_address array based on the additional data
 * provided in the $google_address array. This may involve tweaking of the
 * 'latitude' and 'longitude' entries so that they remain consistent with the
 * street address components.
 *
 * @param $google_address
 * @param $ip_geoloc_address
 * @return TRUE, unless $google_address or $ip_geoloc_address are empty
 */
function ip_geoloc_flatten_google_address($google_address, &$ip_geoloc_address) {
  if (is_array($google_address['address_components']) && is_array($ip_geoloc_address)) {
    //ip_geoloc_debug(t('IP Geolocation: flattening Google address into IP Geolocation address...'));
    foreach ($google_address['address_components'] as $component) {
      $long_name = $component['long_name'];
      if (!empty($long_name)) {
        $type = $component['types'][0];
        $ip_geoloc_address[$type] = $long_name;
        if ($type == 'country' && !empty($component['short_name'])) {
          $ip_geoloc_address['country_code'] = $component['short_name'];
        }
      }
    }
    $ip_geoloc_address['formatted_address'] = $google_address['formatted_address'];
    // The following may be slightly different from the original lat,long passed
    // into ip_geoloc_reverse_geocode().
    $ip_geoloc_address['latitude']  = $google_address['geometry']['location']['lat'];
    $ip_geoloc_address['longitude'] = $google_address['geometry']['location']['lng'];
    return TRUE;
  }
  return FALSE;
}

/**
 * Go through all the IP addresses in the {accesslog} table (Statistics module).
 * For each IP address not yet recorded in the {ip_geoloc} table, retrieve its
 * geolocation data and store in {ip_geoloc}.
 * This is a one-off process. Once synchronised the {ip_geoloc} table will lock
 * step with the {accesslog} table.
 * Returns the number of {accesslog} records processed or FALSE if no IP
 * geolocation retrieval function was found.
 *
 * Note: modules supported for the backfill currently are:
 *   Smart IP module
 *   GeoIP API module
 *   custom modules that implement hook_get_ip_geolocation_alter().
 */
function ip_geoloc_sync_with_accesslog() {
  drupal_get_messages(); // wipe previous message to avoid confusion

  $use_smart_ip = variable_get('ip_geoloc_smart_ip_as_backup', TRUE) && module_exists('smart_ip');
  $use_google_to_reverse_geocode = variable_get('ip_geoloc_google_to_reverse_geocode', TRUE);

  $batch_size = check_plain($_POST['ip_geoloc_sync_batch_size']); // from Configuration >> IP Geolocation form
  if (empty($batch_size)) {
    $batch_size = variable_get('ip_geoloc_sync_batch_size', 500);
  }
  $ips_to_be_processed = ip_geoloc_ips_to_be_synched();
  if (count($ips_to_be_processed) > $batch_size) {
    $ips_to_be_processed = array_slice($ips_to_be_processed, 0, $batch_size, TRUE);
  }
  $count = count($ips_to_be_processed);

  $batch = array(
    'operations' => array(array('_ip_geoloc_process_access_log', array($ips_to_be_processed, $use_smart_ip, $use_google_to_reverse_geocode))),
    'title' => t('Processing next %count IP addresses from access log', array('%count' => $count)),
    'progress_message' => t('Time elapsed: @elapsed. Time remaining: @estimate.'),
    'error_message' => t('An error occurred while processing the access log.'),
    'finished' => '_ip_geoloc_process_access_log_finished'
  );
  batch_set($batch);

  return $count;
}

function _ip_geoloc_process_access_log($ips_to_be_processed, $use_smart_ip, $use_google_to_reverse_geocode, &$context) {
  $sandbox = &$context['sandbox'];
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['max'] = count($ips_to_be_processed);
    $sandbox['ips'] = $ips_to_be_processed;
  }
  $location = array('ip_address' => array_shift($sandbox['ips']));

  if (empty($use_smart_ip)) {
    if (module_exists('geoip')) {
      ip_geoloc_use_geoip_api($location);
    }
  }
  else {
    // Depending on the value of the variable 'smart_ip_use_ipinfodb_service'
    // this will either use the IPInfoDB web service or Smart IP's database, as
    // created by importing the MaxMind CSV archive.
    $location = smart_ip_get_location($location['ip_address']);
  }

  if (!empty($use_google_to_reverse_geocode)) {
    // Use the Google web service
    $google_address = ip_geoloc_reverse_geocode($location['latitude'], $location['longitude']);
    if (!empty($google_address)) {
      ip_geoloc_flatten_google_address($google_address, $location);
    }
  }
  // Allow contributed modules to do their thing taking advantage of what's
  // done above (if anything) or discarding it
  drupal_alter('get_ip_geolocation', $location);

  if (empty($location['formatted_address'])) {
    // Just so that a record is created and the IP is taken off the list
    $location['formatted_address'] = '-';
  }
  if (ip_geoloc_store_location($location) === FALSE) {
    return;
  }

  // Update our progress information.
  $sandbox['progress']++;
  // Store result for post-processing in the _finished callback.
  $context['results'][] = $location['ip_address'] . ': ' . (empty($location['formatted_address']) ? '?' : $location['formatted_address']);
  // Provide to the batch engine an estimate of the level of completion so far.
  if ($sandbox['progress'] < $sandbox['max']) {
    // Note the addition of 100 in the formula below. This is to make sure that
    // batch sizes of 200 or greater do not terminate prematurely.
    // E.g 199/200 = 0.995 ends up being rounded to 100% causing abort.
    $context['finished'] = floor(100 * $sandbox['progress'] / $sandbox['max']) / 100;
  }
}

function _ip_geoloc_process_access_log_finished($success, $results, $operations, $elapsed) {
  if ($success) {
    drupal_set_message(t("%count new IP geolocation records compiled and stored in %elapsed-time.",
      array('%count' => count($results), '%elapsed-time' => $elapsed)));
  }
  else {
    drupal_set_message(t('An error occurred. Processing of the access log did not complete.'), 'error');
    $message = format_plural(count($results), 'One IP address successfully processed:', '@count IP addresses successfully processed:');
    $message .= theme('item_list', array('items' => $results));
    drupal_set_message($message);
  }
}

function ip_geoloc_erase_session() {
  drupal_get_messages();
  unset($_SESSION['ip_geoloc']);
  drupal_set_message(t('Geolocation data erased from session.'));
}

function ip_geoloc_erase_db() {
  drupal_get_messages(); // wipe previous messages to avoid confusion
  $result = db_delete('ip_geoloc')->execute();
}

/*
 *  Return an array of all IP addresses in the current access log that have not
 *  yet had their geolocation data added to the ip_geoloc table.
 */
function ip_geoloc_ips_to_be_synched() {
  if (!db_table_exists('accesslog')) {
    return array();
  }
  $hostnames = db_query('SELECT DISTINCT hostname FROM {accesslog} ORDER BY aid DESC')->fetchCol('hostname');
  $ip_geolocations = db_query('SELECT DISTINCT ip_address FROM {ip_geoloc}')->fetchCol('ip_address');
  return array_diff($hostnames, $ip_geolocations);
}

function ip_geoloc_pretty_print($location) {
  $t = '';
  foreach ($location as $label => $value) {
    if (!empty($value)) {
      $t .= check_plain($label) . ":&nbsp;<strong>" . check_plain($value) . "</strong>&nbsp; ";
    }
  }
  return empty($t) ? t('nothing') : $t;
}

function ip_geoloc_debug($message, $type = 'status') {
  if ($GLOBALS['user']->uid == 1 && variable_get('ip_geoloc_debug', FAlSE)) {
    drupal_set_message($message, $type);
  }
}

/**
 * Implements hook_views_api().
 */
function ip_geoloc_views_api() {
  return array(
    'api' => views_api_version(),
    'path' => drupal_get_path('module', 'ip_geoloc') . '/views'
  );
}

/**
 * Implements hook_smart_ip_get_location_alter().
 *
 * Called from the bottom of smart_ip_get_location() when it has fleshed out
 * the $location array as much as it can.
 * @obsolete
 */
function ip_geoloc_smart_ip_get_location_alter(&$location) {
  if (empty($location['postal_code'])) {
    $location['postal_code'] = $location['zip'];
  }
  ip_geoloc_format_address($location);
  ip_geoloc_debug(t('IP Geolocation: Smart IP retrieved: !location', array('!location' => ip_geoloc_pretty_print($location))));
}

/**
 * Implements hook_device_geolocation_detector_ajax_alter().
 *
 * This is called from device_geolocation_detector_ajax(), the AJAX callback
 * that receives in the $_POST array the address data from Google geocoding.
 * @obsolete
 */
function ip_geoloc_device_geolocation_detector_ajax_alter(&$location) {
  ip_geoloc_debug(t('IP Geolocation: Device Geolocation retrieved: !location', array('!location' => ip_geoloc_pretty_print($location))));
}
